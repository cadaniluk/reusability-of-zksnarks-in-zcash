% \boldsymbol{n}_1^\text{old},\boldsymbol{n}_2^\text{old}
% a^\text{old}_\text{sk,$1$},a^\text{old}_\text{sk,$2$}


\typeout{IJCAI-11 Instructions for Authors}

% These are the instructions for authors for IJCAI-11.
% They are the same as the ones for IJCAI-07 with superficical wording
%   changes only.

\documentclass{article}
% The file ijcai11.sty is the style file for IJCAI-11 (same as ijcai07.sty).
\usepackage{ijcai11}

% Use the postscript times font!
\usepackage{times}

\usepackage{makecell}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{complexity}
\usepackage{adjustbox}
\usepackage[binary-units=true]{siunitx}

% the following package is optional:
%\usepackage{latexsym} 

% Following comment is from ijcai97-submit.tex:
% The preparation of these files was supported by Schlumberger Palo Alto
% Research, AT\&T Bell Laboratories, and Morgan Kaufmann Publishers.
% Shirley Jowell, of Morgan Kaufmann Publishers, and Peter F.
% Patel-Schneider, of AT\&T Bell Laboratories collaborated on their
% preparation.

% These instructions can be modified and used in other conferences as long
% as credit to the authors and supporting agencies is retained, this notice
% is not changed, and further modification or reuse is not restricted.
% Neither Shirley Jowell nor Peter F. Patel-Schneider can be listed as
% contacts for providing assistance without their prior permission.

% To use for other conferences, change references to files and the
% conference appropriate and use other authors, contacts, publishers, and
% organizations.
% Also change the deadline and address for returning papers and the length and
% page charge instructions.
% Put where the files are available in the appropriate places.


\title{The Reusability of zk-SNARKs in the Zcash Protocol}
%\thanks{These match the formatting instructions of IJCAI-07. The support of IJCAI, Inc. is acknowledged.}}
\author{Cordian A. Daniluk \\ 
Laboratoire Jean Kuntzmann\\
Grenoble, France \\
cordian.daniluk@grenoble-inp.org \\
\\
Supervised by: Aude Maignan} % Mosig student

\begin{document}

\maketitle

{% Mosig student
  {\hbox to0pt{\vbox{\baselineskip=10dd\hrule\hbox
to\hsize{\vrule\kern3pt\vbox{\kern3pt
\hbox{{\small I understand what plagiarism entails and I declare that this report }}
\hbox{{\small is my own, original work. }}
\hbox{{\small Cordian A. Daniluk, March 30th, 2022:}}
\kern3pt
}\hfil%\kern3pt
\vrule
}\hrule}
}}
}

\begin{abstract}
A method to speed up repeated creation of a zk-SNARK in JoinSplit descriptions of Zcash transactions given another similar, previously created zk-SNARK is presented.
The cryptocurrency Zcash and zk-SNARKs are introduced, explaining why optimizing the repeated creation of zk-SNARKs is useful in the context of Zcash.
A mechanism using zk-SNARKs to send money in Zcash called JoinSplit description is explained, with some focus on the Groth16 proving system.
Conceivable situations are described when such optimization can be beneficial to performance.
The optimization techniques themselves are detailed.
\end{abstract}

\section{Introduction}

Cryptocurrencies such as Bitcoin \cite{nakamoto:bitcoin} were designed with the goal to decentralize money transfer.
There should not be a central trusted party such as a bank, through which passes every transaction to remove the need for trust.
However, without any trusted party, transactions are not checked for validity such as the fact that a spender must really be the owner of the spent money and that a spender cannot spend money twice.

A commonly used solution by cryptocurrencies to enforce these rules and yet others is a public ledger called the blockchain \cite{nakamoto:bitcoin}.
The public nature of this data structure enables any node in the cryptocurrency's network to verify rules such as ownership of spent money or double-spending money.
However, without appropriate measures a public ledger can lead to compromised privacy by revealing information such as the identities of transaction participants.
In the special case of Bitcoin, a spent amount of money is associated with a destination address, effectively a user's pseudonym.
A user may employ an arbitrary number of pseudonyms to hide their true identity and additionally use methods similar to money laundering, but even these fail to guarantee anonymity \cite{reid:bitcoin-anon}.
Hence, people have tried improving anonymity in new cryptocurrencies such as Monero \cite{saberhagen:cryptonote} or Zcash \cite{hopwood:zcash}.
Zcash is the one this internship is focusing on.

Zcash still uses a blockchain, but to make stronger anonymity guarantees than Bitcoin, Zcash offers partially or fully shielded transactions as well as transparent transactions inherited from Bitcoin.
While the latter leak data such as the pseudonyms of senders and receivers, the former hide it by either encrypting sensitive information on the blockchain in an anonymity-preserving way or not including it at all.
This lack of inclusion needs additional care, however, since classical Bitcoin nodes need some public information such as a sender's pseudonym to enforce the blockchain's validity.
To this end, a cryptographic construct called \textit{zero-knowledge succinct non-interactive argument of knowledge} (zk-SNARK) is used.
A zk-SNARK has public and secret inputs.
The former are publicly known, the latter are only known to the sender.
The sender adds all sensitive information as the secret input and some other as the public input, creates a zk-SNARK from these, and adds it to a shielded transaction.
The zk-SNARK expresses the statement that the sender knows secret inputs such as the monetary value of the inputs such that the transaction is valid:
for example, it is verified that the sender rightfully claims ownership of a given amount of money.
Upon inclusion in the blockchain, anyone can verify the zk-SNARK to enforce the transaction's validity.
Hence, nodes do not do this on public data directly included in the blockchain as in Bitcoin, but on a zk-SNARK, which enables validation of transactions without revealing its secret inputs.

The various properties of zk-SNARKs render them useful in Zcash: they are zero-knowledge, meaning that they prove statements given secret inputs without revealing them.
Their succinctness makes for proofs of small size and short verification time by nodes in the Zcash network.
Since they are non-interactive, unlike proposed by, for example, the foundational paper of zero-knowledge proofs \cite{goldwasser:zk}, they can be included in the blockchain without further communication between sender and other parties.
Finally, they are arguments, meaning that a malicious, computationally bounded sender cannot fake proofs to mislead nodes in the network.
More specifically, they are arguments of knowledge, which means that not only do secret inputs exist that satisfy the proven statement, but also that the prover knows them.
For a formal definition of zk-SNARKs, see \cite{groth:zksnark}, for example.

Beyond its theoretical definition, zk-SNARKs steadily evolve to make them even more practical.
In Zcash alone, three different zk-SNARKs (\cite{bensasson:zksnark} in the Sprout version, \cite{groth:zksnark} in the Sapling version, \cite{zcash:halo2} in the Orchard version) have been used throughout the protocol's history.
One reason for this evolution is the effort to reduce time and space requirements of the creation of zk-SNARKs:
we have measured JoinSplit descriptions, a certain method to send money in a shielded way (see Section \ref{sec:joinsplit}) using a zk-SNARK, to take about \SI{25}{\second} in time and about \SI{1}{\gibi\byte} in space (the computer used for these measurements is given in Section \ref{sec:benchmarks}) on a current Zcash node (zcashd v5.5.1).

There might be situations where the creation of zk-SNARKs does not have to be done from scratch: the network might have rejected a transaction containing a JoinSplit description and the user wants to resend it, so information from the previous transaction could be reusable.
This document will focus on two reasons for rejection: insufficient transaction fees, which leads to no miner wanting to include the transaction in a block, and chain reorganizations, where blocks become stale because another branch with higher total work performed by miners has overtaken them (more detail is given in Section \ref{sec:changed}).
It will investigate under what circumstances and to what degree the zk-SNARKs in the resent transactions have to be entirely recalculated, modified, or can be left as is.
The used zk-SNARK is Groth16 \cite{groth:zksnark}, which is used since the Sapling network upgrade.
While it is used for other sending mechanisms than JoinSplit descriptions, only these shall be considered in this report.
Additionally, resending will only be considered for transactions sent by a Zcash full node on that same node; there are also lightweight clients, which store less information and are therefore usable on less powerful computers, but these are not considered.
With an efficient resending mechanism, we hope to improve performance of the otherwise costly zk-SNARK creation of JoinSplit descriptions in Sprout and Sapling.

The report is structured as follows: Section \ref{sec:joinsplit} gives some background information on JoinSplit descriptions in Zcash, including the Groth16 zk-SNARK used since Sapling.
Section \ref{sec:resending} explains the actual optimization methods.
This includes a description of the handled cases of transaction rejection as well as practical considerations of these optimizations.
Section \ref{sec:conclusion} concludes the report, summarizing the results and evaluating their effectiveness.
Section \ref{sec:future} provides some suggestions for future work.

\section{JoinSplit Descriptions} \label{sec:joinsplit}

In general, Sprout transactions consist of several fields such as version information or a signature, as well as JoinSplit descriptions (in the following also abbreviated as JoinSplit).
Only the latter are relevant to this paper, so we will not detail any further the other parts and only informally explain JoinSplits.
For a full listing and detailed explanation of transaction elements, see \cite{hopwood:zcash}.

JoinSplit descriptions are composed of the elements in Table \ref{fig:joinsplit}, which also contains public inputs to the zk-SNARK $\pi_\text{ZKJoinSplit}$.
The secret inputs to $\pi_\text{ZKJoinSplit}$ are listed in Table \ref{fig:secretinputs}.
All fields mentioned in this section are detailed in these two tables.

As the name says, a JoinSplit joins the value of two old \textit{shielded notes} that represent some monetary value and splits that sum into two new shielded notes.
A note is owned by a Zcash user, so JoinSplits can be used to send money (the owner of old and new notes differs) to one or two recipients without publicly revealing any user's identity or to arrange money in different ways in one user's wallet (the owner of old and new notes is the same).
Concretely, a node that sends a JoinSplit creates new shielded notes $\boldsymbol{n}^\text{new}_1,\boldsymbol{n}^\text{new}_2$, which contain elements given in their description in Table \ref{fig:secretinputs}, and spends two old shielded notes $\boldsymbol{n}^\text{old}_1,\boldsymbol{n}^\text{old}_2$.
Instead of revealing $\boldsymbol{n}^\text{new}_1,\boldsymbol{n}^\text{new}_2$, which would reveal the future owner's public key harming anonymity, the node creates cryptographically hiding and binding commitments of $\boldsymbol{n}^\text{new}_1,\boldsymbol{n}^\text{new}_2$ denoted by $\text{cm}_1^\text{new}, {\text{cm}_2^\text{new}}$.
These commitments are publicly stored in the leaves of a binary Merkle tree \cite{merkle:tree}, the \textit{commitment tree}.
This tree evolves with each JoinSplit added to the blockchain and has well-defined states after every block and every JoinSplit.
There is a one-to-one association between a shielded note and its commitment.

If a user wants to spend two shielded notes, he proves ownership of these by proving knowledge of the secret spending keys $a_\text{sk,$1$}^\text{old}, a_\text{sk,$2$}^\text{old}$ and their associated commitments' existence by proving their membership in the commitment tree of some block or JoinSplit.
Furthermore, the user reveals nullifiers $\text{nf}_1^\text{old}, {\text{nf}_2^\text{old}}$ that correspond one-to-one to the shielded notes $\boldsymbol{n}^\text{old}_1,\boldsymbol{n}^\text{old}_2$.
Publishing the nullifiers enables other nodes to check if shielded notes with the same nullifiers have already been spent and prevent double-spending.
While the public only learns $\text{cm}_1^\text{new}, {\text{cm}_2^\text{new}}$, the receiver needs the full shielded notes $\boldsymbol{n}^\text{new}_1,\boldsymbol{n}^\text{new}_2$, so that he can spend them later on by using them as $\boldsymbol{n}^\text{old}_1,\boldsymbol{n}^\text{old}_2$ in a JoinSplit.
The spender encrypts these new shielded notes and puts them as $C_1^\text{enc}, C_2^\text{enc}$ in the JoinSplit in a manner such that the receiver can decrypt them, but no one else can.
Finally, measures against malleability are taken and $\pi_\text{ZKJoinSplit}$ is created.

A JoinSplit always has two nullifiers and two new commitments.
To use only one of either, \textit{dummy notes} can be used.

The most prominent element of a JoinSplit is $\pi_\text{ZKJoinSplit}$ that proves a statement about the JoinSplit's validity such that others can verify that the JoinSplit is indeed valid.
$\pi_\text{ZKJoinSplit}$ enforces rules such as

\begin{align}v_\text{pub}^\text{old} + v_1^\text{old} + v_2^\text{old} = v_\text{pub}^\text{new} + v_1^\text{new} + v_2^\text{new} \label{eq:balance}\end{align}

or the aforementioned membership of commitments in the commitment tree: for $i \in \{1,2\}$, if $\text{enforceMerklePath}_i = 1$, then $\text{path}_i$ is a valid Merkle path from the commitment corresponding to $\boldsymbol{n}_i^\text{old}$ at index $\text{pos}_i$ to the root $\text{rt}^\text{Sprout}$.
Other rules are enforced, such as whether $a^\text{old}_{\text{sk},i}$ fits $a_{\text{pk},i}$ to prove the spender's possession of the shielded note. However, detailed knowledge of the rules is not relevant for the remainder and can be acquired from \cite{hopwood:zcash}.

$\pi_\text{ZKJoinSplit}$ is created using the Groth16 \cite{groth:zksnark} proving system, so the next section will explain informally how proof creation works.
For a rigorous treatment, see the original paper.

\begin{center}
\begin{table}
{\tiny
\begin{tabular}{ |c|c| } 
        \hline
        \textbf{Name} & \textbf{Description} \\
        \hline
        \rule{0pt}{4ex} {\small ${v_\text{pub}^\text{old}}^\ast$} & \makecell{A value that is drawn from a transparent input and can be used\\ for new commitments in JoinSplits. $0$ if $v_\text{pub}^\text{new} \neq 0$.} \\
        \hline
        \rule{0pt}{4ex} {\small ${v_\text{pub}^\text{new}}^\ast$} & \makecell{A value that is drawn from a shielded note and can be used for\\ a transparent output. $0$ if $v_\text{pub}^\text{old} \neq 0$.} \\
        \hline
        \rule{0pt}{4ex} {\small ${\text{rt}^\text{Sprout}}^\ast$} & \makecell{A root of the commitment tree at some \\ blockheight in the past or a root produced by\\ a previous JoinSplit in the same transaction.} \\
        \hline
        \rule{0pt}{4ex} {\small $\text{nf}_1^\text{old}, {\text{nf}_2^\text{old}}^\ast$} & \makecell{Nullifiers that refer to shielded notes and are made public to prevent\\ double-spending.} \\
        \hline
        \rule{0pt}{4ex} {\small $\text{cm}_1^\text{new}, {\text{cm}_2^\text{new}}^\ast$} & \makecell{Commitments to new shielded notes. For $i \in \{1,2\}$,\\ $\text{cm}_i^\text{new}$ is calculated from $\boldsymbol{n}^\text{new}_i$ as follows:\\$\text{cm}_i^\text{new} = \text{SHA-256}(\text{0xB0} \mid a_\text{pk,$i$}^\text{new} \mid v_i^\text{new} \mid \rho_i^\text{new} \mid \text{rcm}_i^\text{new})$\\ where $\mid$ denotes bitwise concatenation.} \\
        \hline
        \rule{0pt}{4ex} {\small epk} & A public key relevant to the creation of $C_1^\text{enc}, C_2^\text{enc}$. \\
        \hline
        \rule{0pt}{4ex} {\small randomSeed} & \makecell{A random value that is used in the creation of $C_1^\text{enc}, C_2^\text{enc}$ and\\ $h_1, h_2$.} \\
        \hline
        \rule{0pt}{4ex} {\small $h_1, h_2^\ast$} & MAC tags that help enforcing non-malleability of the JoinSplit. \\
        \hline
        \rule{0pt}{4ex} {\small $\pi_\text{ZKJoinSplit}$} & An encoding of the zk-SNARK. \\
        \hline
        \rule{0pt}{4ex} {\small $C_1^\text{enc}, C_2^\text{enc}$} & The new shielded notes in encrypted form destined for the receiver. \\
        \hline
\end{tabular}}
\caption{A JoinSplit description. Public inputs to $\pi_\text{ZKJoinSplit}$ are a subset of these fields and marked with $^\ast$. The fields' names are the same ones as in the original \protect\cite{hopwood:zcash}.} \label{fig:joinsplit}
\end{table}
\end{center}

\begin{center}
\begin{table}
{\tiny
\begin{tabular}{ |c|c| } 
        \hline
        \textbf{Name} & \textbf{Description} \\
        \hline
        \rule{0pt}{4ex} {\small $\varphi$} & \makecell{A randomly sampled value used to verify\\ uniqueness of $\rho_1^\text{new}, \rho_2^\text{new}$.} \\
        \hline
        \rule{0pt}{4ex} {\small $\boldsymbol{n}^\text{old}_1,\boldsymbol{n}^\text{old}_2$} & \makecell{$\forall i \in \{1,2\}\colon \boldsymbol{n}^\text{old}_i = (a_\text{pk,$i$}^\text{old}, v_i^\text{old}, \rho_i^\text{old}, \text{rcm}_i^\text{old})$\\ The content of the shielded notes about to be spent\\ by revealing their associated nullifier.\\ $a_\text{pk,$i$}^\text{old}$ is a public key identifying the owner. $v_i^\text{old}$ is\\ the monetary value contained in the shielded note. $\rho_i^\text{old}$\\ is a unique identifier to avoid double-spending. $\text{rcm}_i^\text{old}$\\ is a random commitment trapdoor that is part of the\\ commitment scheme.} \\
        \hline
        \rule{0pt}{4ex} {\small $a_\text{sk,$1$}^\text{old},a_\text{sk,$2$}^\text{old}$} & \makecell{Secret keys that match $a_\text{pk,$1$}^\text{old}, a_\text{pk,$2$}^\text{old}$. Amongst\\ others, used to prove ownership of $\boldsymbol{n}^\text{old}_1,\boldsymbol{n}^\text{old}_2$.} \\
        \hline
        \rule{0pt}{4ex} {\small $\boldsymbol{n}^\text{new}_1,\boldsymbol{n}^\text{new}_2$} & \makecell{$\forall i \in \{1,2\}\colon \boldsymbol{n}^\text{new}_i = (a_\text{pk,$i$}^\text{new}, v_i^\text{new}, \rho_i^\text{new}, \text{rcm}_i^\text{new})$\\ The content of the shielded notes about to be produced.\\ $a_\text{pk,$i$}^\text{new}$ is a public key identifying the receiver. $v_i^\text{new}$ is the\\ monetary value sent to the receiver. $\rho_i^\text{new}$ is a unique\\ identifier to avoid double-spending. $\text{rcm}_i^\text{new}$ is a\\ random commitment trapdoor that is part of the\\ commitment scheme.} \\
        \hline
        \rule{0pt}{4ex} {\small \makecell{$\text{enforceMerklePath}_1$,\\ $\text{enforceMerklePath}_2$}} & \makecell{A bit that indicates if the path in the commitment tree \\ should be verified. Set to $0$ for dummy notes.} \\
        \hline
        \rule{0pt}{4ex} {\small $\text{path}_1,\text{path}_2$} & \makecell{The path of the respective commitment in the\\ commitment tree.} \\
        \hline
        \rule{0pt}{4ex} {\small $\text{pos}_1, \text{pos}_2$} & \makecell{The index of the respective commitment in the leaves of \\ the commitment tree. The leaves are enumerated\\ from left to right starting from $0$. Empty\\ leaves have the value $0$.} \\
        \hline
\end{tabular}}
\caption{The secret inputs to $\pi_\text{ZKJoinSplit}$. The fields' names are the same ones as in the original \protect\cite{hopwood:zcash}.} \label{fig:secretinputs}
\end{table}
\end{center}

\subsection{The Groth16 zk-SNARK} \label{sec:groth16}

The Groth16 proving system provides a way to prove statements of the form $x \in L$ for some language $L \in \NP$.
For Zcash, $x$ would be the public input to $\pi_\text{ZKJoinSplit}$ marked with $^\ast$ in Table \ref{fig:joinsplit} and $L$ is the statement ``$x$ is a valid JoinSplit according to the rules mentioned in Section \ref{sec:joinsplit}''.
In this section, we will show informally how a zk-SNARK is produced from such a statement $x \in L$ by reducing $L$ to another problem ARITH-SAT and then encoding ARITH-SAT as a so-called QAP for the creation of $\pi_\text{ZKJoinSplit}$.

$L \in \NP$, so there exists an efficient algorithm $A(x, w)$ such that

\begin{align*} L = \{ x \in \{0,1\}^\ast \colon \exists w \in \{0,1\}^\ast\colon A(x, w) = 0\} \end{align*}

For Zcash, $w$ corresponds to the secret inputs to $\pi_\text{ZKJoinSplit}$ in Table \ref{fig:secretinputs}.
Now, let $q$ be prime and $\mathbb{F}_q$ be a $q$-order finite field.
For an arithmetic circuit\footnote{For an illustrative image of an arithmetic circuit, see \cite{gennaro:qap} Figure 1.} $C$, let $m + 1$ be the number of wires of $C$, including inputs.
Let $l$ be the number of public inputs and w.l.o.g. assign wires $1$ through $l$ to them.
For practical purposes, wire $0$ is assumed to carry the value $1$.
Now, define ARITH-SAT to be the following language:

\begin{align*}
        \text{ARITH-SAT} := \left\{\begin{aligned}\text{An arithmetic circuit } C \text{ and } x \in \mathbb{F}_q^l \colon \\
        \exists w \in \mathbb{F}_q^{m-l}\colon C(x,w) = 0\end{aligned}\right\}
\end{align*}

$C(x,w)$ represents the output of $C$ if wires are assigned the values in $x$ and $w$.
$x$ is called the ``primary input'', $w$ the ``auxiliary input'' or ``witness''.
Denote the value of wire $i$, including both inputs and wire $0$, by $a_i$.
Then $x = (a_i)_{i=1}^l$ and $w = (a_i)_{i=l+1}^m$.
ARITH-SAT is \NP-complete (similarly to how 3-SAT is \NP-complete), so $L \leq_p \text{ARITH-SAT}$ and $x \in L$ can be efficiently converted into a form $x_C \in \text{ARITH-SAT}$.

For $n$ multiplication gates in $C$, choose $r_1, \ldots, r_n$ pairwise distinct in $\mathbb{F}_q$.

Next, define a quadratic arithmetic program (QAP) $Q$ as

\begin{align*}
        Q := \left(\begin{aligned}\{u_i \in \mathbb{F}_q[x] \colon i \in [m]\},\{v_i \in \mathbb{F}_q[x] \colon i \in [m]\},\\
        \{w_i \in \mathbb{F}_q[x] \colon i \in [m]\}, t \in \mathbb{F}_q[x]\end{aligned}\right)
\end{align*}

Set $t(x) := \prod_{i=1}^n(x-r_i)$.
$Q$ computes an arithmetic circuit $C$ if $x_C = (C,x) \in \text{ARITH-SAT} \iff \text{there exist } a_i$ such that

\begin{align*}
        t(x) \mid \overbrace{\underbrace{\sum_{i=0}^m a_iu_i(x)}_\text{left input} \cdot \underbrace{\sum_{i=0}^m a_iv_i(x)}_\text{right input} - \underbrace{\sum_{i=0}^{m} a_iw_i(x)}_\text{output}}^\text{$P_Q(x)$}
\end{align*}

The idea is that $P_Q(r_i) = 0$ corresponds to the statement ``left input times right input minus output equals zero'' for the $i^\text{th}$ multiplication gate.
Note that the inputs and output are actually not only mere wire values $a_i$, but linear combinations of many wire values.
Practically, this means that every multiplication gate can subsume many addition and scalar multiplication gates (i.e., linear operations).
The coefficients of these linear combinations are hardcoded into $Q$'s polynomials using Lagrange interpolation or discrete Fourier transforms (see Section \ref{sec:opt}), for example.

Every multiplication gate is satisfied if and only if $r_1,\ldots,r_n$ are zeros of $P_Q$.
This is given by divisibility by $t$.
For full details on QAPs, see \cite{gennaro:qap}.

Before proving, we need to setup some shared information $\sigma$ between prover and verifier called the \textit{common reference string}.
Let $(G_1, +), (G_2, +)$ be two cyclic $q$-order subgroups of points on certain elliptic curves with generators $g_1, g_2$, respectively.
Zcash uses the BLS12-381\cite{barreto:bls} curve, so $G_1,G_2$ are chosen accordingly.
For full detail, see \cite{hopwood:zcash}.

Sample randomly $\alpha, \beta, \gamma, \delta, \tau \in \mathbb{F}_q$. Define $\sigma := (\sigma_1, \sigma_2)$ as

\begin{adjustbox}{max width=.5\textwidth}
\parbox{\linewidth}{
\begin{align*}
        \sigma_1 &:= \left\{\begin{aligned}\left(g_1\frac{\beta u_i(\tau) + \alpha v_i(\tau) + w_i(\tau)}{\delta}\right)_{i=l+1}^m =: \boldsymbol\sigma_{1,1},\\
        \left(g_1\frac{\tau^i t(\tau)}{\delta}\right)_{i=0}^{n-2} =: \boldsymbol\sigma_{1,2}, \left(g_1{\tau^i}\right)_{i=0}^{n-1} =: \boldsymbol\sigma_{1,3},\\
        g_1\alpha, g_1\beta, g_1\delta, \left(g_1\frac{\beta u_i(\tau) + \alpha v_i(\tau) + w_i(\tau)}{\gamma}\right)_{i=0}^l\end{aligned}\right\} \\
        \sigma_2 &:= \left\{g_2\beta, g_2\gamma, g_2\delta, (g_2{\tau^i})_{i=0}^{n-1} =: \boldsymbol\sigma_{2,4}\right\}
\end{align*}}
\end{adjustbox}

Given $Q$, the prover now calculates $h \in \mathbb{F}_q[x]$ as

\begin{align}h(x) := \frac{\sum_{i=0}^m a_iu_i(x) \cdot \sum_{i=0}^m a_iv_i(x) - \sum_{i=0}^{m} a_iw_i(x)}{t(x)} \label{eq:h}\end{align}

and obtains the vector of coefficients of $h(x)$ denoted by $\boldsymbol{h}$.
Then, the proof $\pi$ (or, more concretely, in our case $\pi_\text{ZKJoinSplit}$) for the statement $x \in L$ is $\pi := (g_1A =: \pi_A, g_2B =: \pi_B, g_1C =: \pi_C)$, where, given randomly sampled $r,s\in \mathbb{F}_q$,

\begin{align}
        A &:= \alpha + \sum_{i=0}^m a_iu_i(\tau) + r\delta \label{eq:A} \\
        B &:= \beta + \sum_{i=0}^m a_iv_i(\tau) + s\delta \label{eq:B} \\
        C &:= \frac{\sum_{i=l+1}^m a_i(\beta u_i(\tau) + \alpha v_i(\tau) + w_i(\tau)) + h(\tau)t(\tau)}{\delta} \label{eq:C} \\
        & + As + Br - rs\delta \nonumber
\end{align}

Given the evaluations of $(g_1{u_i(\tau)})_{i=0}^m$, $(g_1{v_i(\tau)})_{i=0}^m$, and $(g_2{v_i(\tau)})_{i=0}^m$, which can be computed as they are composed of the elements of $\boldsymbol\sigma_{1,3}$ and $\boldsymbol\sigma_{2,4}$, the prover can evaluate the elements using $\sigma$ as follows:

\begin{align}
        g_1A &= g_1\alpha + \sum_{i=0}^m {(g_1{u_i(\tau)})}{a_i} + {(g_1{\delta})}r \label{eq:gA} \\
        g_1B &= g_1\beta + \sum_{i=0}^m {(g_1{v_i(\tau)})}{a_i} + {(g_1{\delta})}s \label{eq:g1B} \\
        g_2B &= g_2\beta + \sum_{i=0}^m {(g_2{v_i(\tau)})}{a_i} + {(g_2{\delta})}s \label{eq:g2B} \\
        g_1C &= \boldsymbol\sigma_{1,1}(a_i)_{i=l+1}^m + \boldsymbol\sigma_{1,2}\boldsymbol{h} + {(g_1A)}s + {(g_1B)}r \nonumber \\
        &+ {(g_1\delta)}{(-rs)} \label{eq:gC} 
\end{align}

Finally, $\pi$ is verified by using a pairing with $G_1$ and $G_2$ as source groups, in Zcash the optimal ate pairing\cite{vercauteren:optimal-ate}, specifically.

\section{Resending Shielded Transactions} \label{sec:resending}

\begin{figure}[t]
\includegraphics[width=8cm]{images/timeline.png}
\caption{Steps involved in resending a transaction.} \label{fig:resend-steps}
\centering
\end{figure}

We assume the series of events in Figure \ref{fig:resend-steps}: a Zcash full node creates and sends a transaction containing a JoinSplit description to its peers.
At some later point, it learns that the transaction has not been included into the blockchain.
The node wants to resend the transaction: it checks what fields need to change, recalculates these and finally resends the transaction.
This process can be repeated until the transaction is in the blockchain.

We assume that the node is capable of sending and resending to a sufficient number of peers, such that failure of the network never prevents the transaction's inclusion.
Hence, we will not deal with the first and the last step of Figure \ref{fig:resend-steps}.
A node can assume that its transaction has been rejected by waiting for the transaction's inclusion and then for its confirmation.
If the node does not find its transaction in its local blockchain after some time, the transaction has been rejected.
This can happen for insufficient transaction fees, for example.
If it is included, but not fully confirmed by a sufficient number of blocks, it has been rejected as well.
This can happen for a chain reorganization.
Once it is certain that a transaction has been rejected, it must be checked what fields of the JoinSplit must change to maximize the chances of inclusion.
All JoinSplit fields, which include public inputs to $\pi_\text{ZKJoinSplit}$, as well as all secret inputs are listed in two tables in Table \ref{fig:joinsplit} and \ref{fig:secretinputs}.

Once it is clear what fields must change, the sender must recalculate them and all other related wire values in the circuit.
Based on the new wire values, a new proof $\pi'_\text{ZKJoinSplit}$ is calculated.
Let $I_\text{changed}$ be the set of indices of coefficients $a_i$ that may change.
Denote the new coefficients by $a'_i$, where $a'_i \neq a_i \implies i \in I_\text{changed}$.
We want to find relationships between the calculations made for $\pi_\text{ZKJoinSplit} := (\pi_A, \pi_B, \pi_C)$ and those made for $\pi'_\text{ZKJoinSplit} := (\pi_A', \pi_B', \pi_C')$ such that a maximal amount from the former can be reused for the latter.

\subsection{Finding $I_\text{changed}$} \label{sec:changed}

The set $I_\text{changed}$ should be kept as small as possible; for the JoinSplit circuit, $l=9$ and $m=1956949$, so $I_\text{changed}$ should be a small percentage of $m$.
As we will see in Section \ref{sec:opt}, this allows for the biggest gains in performance since much of the previous proof can be reused.
Indeed, with reasonable assumptions, the two cases mentioned in the introduction allow $I_\text{changed}$ to be small.

By far the biggest number of wires, about $80\%$ of the circuit, is involved in the verification of the Merkle paths for the input notes as briefly described in Section \ref{sec:joinsplit}:
the hash function used for the Merkle tree is the SHA-256 compression function, which needs many wires.
Should any input change that this computation depends on such as $\text{path}_1$ or $\text{path}_2$, then all involved wires need to be recalculated and $I_\text{changed}$ becomes huge.
Otherwise, it will stay small.

First, we consider the case of changing transaction fees sent to a transparent address.
Anyone sending a transaction pays a small fee to miners in order to incentivize the transaction's inclusion in a block.
Such fees are paid implicitly by keeping the transaction outputs too low: if the sum of input values to a transaction exceeds the sum of output values, then the miner can take ownership of the difference.
However, if the transaction fee is set too low, the miner might decide to give preference to other transactions with higher fees.
Hence, the goal is to choose the minimal fee such that the transaction is included, but not too much money is spent on that either.
If the spender finds the transaction to be rejected, it must be resent with a higher transaction fee.

Paying transaction fees from a JoinSplit description happens by setting $v_\text{pub}^\text{new}$ to some non-zero value.
This amount is then available to the transparent outputs of the containing transaction.
They can spend some of it and the remainder can later be claimed by the miner.
This last step is out of the control of the JoinSplit description, however, so the fundamental mechanism to set and change a transaction fee paid from a JoinSplit transaction is the adjustment of $v_\text{pub}^\text{new}$.

Changing $v_\text{pub}^\text{new}$ affects the balance equation (\ref{eq:balance}) in Section \ref{sec:joinsplit}, verified by $\pi_\text{ZKJoinSplit}$.
Increasing $v_\text{pub}^\text{new}$ necessitates a decrease in either the left-hand side or $v_1^\text{new} + v_2^\text{new}$.
We have $v_\text{pub}^\text{old} = 0$ (see Table \ref{fig:joinsplit}) and changing $v_1^\text{old} + v_2^\text{old}$ would imply a lot more changes because of the tight link to $\boldsymbol{n}^\text{old}_1,\boldsymbol{n}^\text{old}_2$, so we confine ourselves to changing $v_1^\text{new} + v_2^\text{new}$.
Assuming in addition that one of $v_1^\text{new}$ and $v_2^\text{new}$ is sufficient, w.l.o.g. we choose $v_1^\text{new}$.
In addition, $v_1^\text{new}$ is included in $\boldsymbol{n}^\text{new}_1$, so $\text{cm}_1^\text{new}$ must be recalculated.

In total, this makes for a set $I_\text{changed}$ of size

\begin{align*}
        |I_\text{changed}| = \underbrace{1}_\text{$v_\text{pub}^\text{new}$ in $\mathbb{F}_q$} &+ \underbrace{64}_\text{$v_\text{pub}^\text{new}$ in binary} + \underbrace{64}_\text{$v_1^\text{new}$ in binary} \\
        &+ \underbrace{51510}_\text{SHA-256 calculation of $\text{cm}_1$} = 51639
\end{align*}

which is only $\approx 2.6\%$ of all wires.

The second scenario we would like to consider is a blockchain reorganization, frequently called a ``reorg''.
Every node stores in reality not a chain but a tree, since for each height in the blockchain, mined blocks may be proposed by multiple nodes.
The active blockchain is a path from the tree's root to one of its leaves and is the path with the largest accumulated difficulty: each block has an associated difficulty value indicating the effort a miner has to put into mining the block.
It happens that a node receives a mined block that is at a lower height than the tip of its active blockchain.
This new block now is a branch off the active blockchain.
If this branch becomes active after some time because yet other blocks are added and it ends up having higher accumulated difficulty, a blockchain reorganization happens: all blocks that are in the old active chain but not in the new one become stale and its JoinSplits are invalidated.
Because of that invalidation, a user might want to resend a JoinSplit.

Whether $\pi_\text{ZKJoinSplit}$ needs to be recalculated or not depends on how $\text{rt}^\text{Sprout}$ was chosen.
If $\text{rt}^\text{Sprout}$ refers to a commitment tree at some previous blockheight and it is before the branch, no change is needed since $\text{rt}^\text{Sprout}$ refers to a tree far enough in the past.
If it is contained in the branch, $\text{rt}^\text{Sprout}$ changes and so do $\text{path}_1,\text{path}_2$, which requires recalculation of the path verification, dramatically increasing $|I_\text{changed}|$.
Therefore, $\text{rt}^\text{Sprout}$ should always be chosen far enough in the past.
If $\text{rt}^\text{Sprout}$ refers to a commitment tree at some other JoinSplit in the same transaction, $\text{rt}^\text{Sprout}$ of the first JoinSplit which actually refers to a past block must be checked as described above.
In any case, either $\text{rt}^\text{Sprout}$ changes and the optimizations provide practically no advantage, or $\pi_\text{ZKJoinSplit}$ can be fully reused.

\subsection{Optimizing The zk-SNARK's Recalculation} \label{sec:opt}

The steps involved in the calculation of any proof as described in Section \ref{sec:groth16} are

\begin{enumerate}
        \item Circuit synthesis; given the public and secret inputs of a JoinSplit, all wire values $a_i$ must be found, 
        \item calculation of $h$ in (\ref{eq:h}), its coefficients $\boldsymbol{h}$ in particular, and
        \item the calculation of the proof elements $\pi_A, \pi_B, \pi_C$.
\end{enumerate}

Circuit synthesis aims to calculate all wire values $a_i$ that are neither public nor secret inputs such as the intermediate results of the repeated application of SHA-256 to verify that $\text{path}_1, \text{path}_2$ are correct.

Calculating $h$ involves operations on polynomials.
To avoid a time complexity of $\mathcal{O}(d^2)$ for $d$-degree polynomials in coefficient representation for multiplication and division, the polynomials are converted to point representation and operations are performed on the points in linear time.
That conversion is done quickly using fast Fourier transforms (FFT), which computes discrete Fourier transforms in sub-quadratic time.
For a more detailed description of this method, see \cite{cormen:clrs}.

The proof elements are calculated as described in (\ref{eq:gA}) through (\ref{eq:gC}).
The main operation here is \textit{multiexponentiation}: given an integer $k$ and base values $b_1, \ldots, b_k$ and exponents $e_1, \ldots, e_k$, compute $b_1^{e_1}b_2^{e_2}\cdots b_k^{e_k}$.
The sum $\sum_{i=0}^m {(g_1{u_i(\tau)})}{a_i}$ in (\ref{eq:gA}) is one example of this operation (we chose additive notation for $G_1, G_2$, so here, multiexponentiation actually is a dot product between a vector of points on an elliptic curve and a vector of scalars).

Synthesis can be optimized by only recalculating $a'_i$ for $i \in I_\text{changed}$ and copying all other $a_i$.

A similar technique of substitution can be applied to $\pi_A$ and $\pi_B$ as well as $g_1B$ and $\boldsymbol\sigma_{1,1}(a_i)_{i=l+1}^m$ in $\pi_C$.
Given $\pi_A$, $\pi_B$, $g_1B$, and $\boldsymbol\sigma_{1,1}(a_i)_{i=l+1}^m$ in (\ref{eq:gC}), we want to remove all $a_i$ with $i \in I_\text{changed}$ (or $i \in I_\text{changed} \cap \{l+1,\ldots,m\}$ for $\boldsymbol\sigma_{1,1}(a_i)_{i=l+1}^m$) and replace them with $a'_i$.
Define $\pi^-_A := g_1{\sum_{i \in I_\text{changed}}a_iu_i(\tau)}$.
Then, for $\pi_A'$, this replacement is fulfilled by the calculation

\begin{align*}
        \pi_A - \pi^-_A + g_1{\sum_{i \in I_\text{changed}}a_i'u_i(\tau)} =: \pi_A'
\end{align*}

as can be seen from the definition of $A$ in (\ref{eq:A}).
We have created $\pi_A'$ by doing a multiexponentiation using the indices in $i \in I_\text{changed}$ instead of the full range of indices.
If $I_\text{changed}$ is sufficiently small, this may lead to a performance boost.
By defining ``subtraction terms'' like $\pi^-_A$ for $\pi_B$, $g_1B$, and $\boldsymbol\sigma_{1,1}(a_i)_{i=l+1}^m$, very similar calculations can be performed for these other values as well as can be seen from (\ref{eq:B}) and (\ref{eq:C}).

However, by changing $\pi_A = g_1A$ and $g_1B$, we must recalculate ${(g_1A)}s + {(g_1B)}r$ in $\pi_C$.
This requires knowledge of $r$ and $s$.
These would need to be stored for each sent transaction for potential resending until its full confirmation, at which moment $r$ and $s$ can be dropped.

For the multiexponentiation $\boldsymbol\sigma_{1,2}\boldsymbol{h}$, such a simple optimization cannot be performed.
If there exists any $i$ such that $a_i \neq a'_i$, the coefficients of the product polynomial $\sum_{i=0}^ma_iu_i(x)\sum_{i=0}^ma_iv_i(x)$ in (\ref{eq:h}) may all change, which means that all coefficients in $\boldsymbol{h}$ are also affected.
Therefore, there is no clear, exploitable relationship between the wire values $a_i$ and $\boldsymbol{h}$, unlike the structure of $\pi_A$, for example, where a changed $a_i$ affects $\pi_A$ in a very predictable way.

For similar reasons, we did not optimize the computation of $h$ either.
We did not find a relationship between a change in $a_i$ and the results of the FFTs used.

\subsection{Practicality Of The Optimizations} \label{sec:benchmarks}

In order to understand the relative usefulness of speeding up each computation, proof creation of $\pi_\text{ZKJoinSplit}$ without our optimizations was benchmarked.
The used system was a 11th Gen Intel(R) Core(TM) i7-1165G7 CPU at \SI{2.80}{\giga\hertz} with \SI{16}{\gibi\byte} of RAM.
Most calculations are parallelized, and if they are, it was made sure that calculations do not overlap as they do, however, in the original implementation.
The obtained measurements were the following:

\begin{center}
\begin{tabular}{ c|c }
        Calculated Data & Time (in \SI{}{\milli\second}) \\
        \hline
        Synthesis (finding all $a_i$) & 754 \\
        $\boldsymbol{h}$ from $h$ in (\ref{eq:h}) & 3564 \\
        $\boldsymbol{\sigma}_{1,2}\boldsymbol{h}$ in (\ref{eq:gC}) & 13795 \\
        $\boldsymbol{\sigma}_{1,1}(a_i)_{i=l+1}^m$ in (\ref{eq:gC}) & 1398 \\
        $\sum_{i=0}^m(g_1u_i(\tau))a_i$ in (\ref{eq:gA}) & 1396 \\
        $\sum_{i=0}^m(g_1v_i(\tau))a_i$ in (\ref{eq:g1B}) & 576  \\
        $\sum_{i=0}^m(g_2v_i(\tau))a_i$ in (\ref{eq:g2B}) & 1675
\end{tabular}
\end{center}

The multiexponentiation $\boldsymbol{\sigma}_{1,2}\boldsymbol{h}$ and the calculation of $h$ take by far the longest time.
Unfortunately, as explained in Section \ref{sec:opt}, we have not found a viable optimization for these operations.
This severely limits the usefulness of our optimizations in the real world.

The values needed to store after sending a transaction and before notification of full confirmation are $r,s$ and $\pi^-_A$, as well as the similar values for $\pi_B$, $g_1B$, and $\boldsymbol\sigma_{1,1}(a_i)_{i=l+1}^m$.
Choosing the encoding of elements in $G_1$ and $G_2$ used for Zcash \cite{hopwood:zcash} any element in $G_1$ takes 48 bytes and any element in $G_2$ takes 96 bytes.
$q \approx 2^{255}$, so 32 bytes suffice to represent any value in $\mathbb{F}_q$.

This makes for a total additional storage requirement in bytes per transaction of

\begin{align*}
        \underbrace{2\cdot 32}_\text{$r,s \in \mathbb{F}_q$} &+ \underbrace{3\cdot 48}_\text{$\pi^-_A \in G_1$ and similar values for $g_1B$ and $\boldsymbol\sigma_{1,1}(a_i)_{i=l+1}^m$} \\
        &+ \underbrace{96}_\text{The equivalent of $\pi^-_A$ for $\pi_B$ in $G_2$} = 304
\end{align*}

\section{Conclusion} \label{sec:conclusion}

We have provided some ways to optimize the recalculation of a zk-SNARK in previously sent JoinSplit descriptions.
They incur additional temporary storage requirements per transaction that should not be dramatic for systems capable of running full Zcash nodes.
Furthermore, the optimizations are fully backwards-compatible such that any user may decide to apply them or not, leaving all other users unaffected.

Even though no measurements of the optimizations have been made, we believe that the improvements in time are minor, given that the most expensive
computation has not been optimized.
Additionally, creating new JoinSplit transactions is not supported anymore by recent Zcash nodes (zcashd v5.5.1).

\section{Future Work} \label{sec:future}

Most importantly, the theoretical optimizations have to be implemented.
Then, a performance comparison between resending a transaction from scratch and using the optimizations is required, preferably for different real-world scenarios.

More generally, there are potentially other optimizations that can be made when recalculating the proof.
While this report only dealt with fully backward-compatible changes, perhaps there are optimizations that require changes of the CRS or the content of JoinSplit descriptions, which would break backward compatibility.
Furthermore, more recent versions of Zcash support other transaction types such as Spend and Output since Sapling, which are still proved using Groth16 but come with their own circuits.
$I_\text{changed}$ would need to be adjusted to these more recent circuits.
Other scenarios than the two treated in this report may be examined as well, which would require further adjustment of $I_\text{changed}$.

%\subsection{Length of Papers}
%
%Each accepted full paper is allocated six pages in the conference 
%proceedings. Up to two additional pages may be purchased at a price 
%of \$275 per page for any accepted paper. However, all 
%{\em submissions} must 
%be a maximum of six pages in length.
%
%
%\subsection{Word Processing Software}
%
%As detailed below, IJCAI has prepared and made available a set of
%\LaTeX{} macros and a Microsoft Word template for use in formatting
%your paper. If you are using some other word processing software (such
%as WordPerfect, etc.), please follow the format instructions given
%below and ensure that your final paper looks as much like this sample
%as possible.
%
%\section{Style and Format}
%
%\LaTeX{} and Word style files that implement these instructions
%can be retrieved electronically. (See Appendix~\ref{stylefiles} for
%instructions on how to obtain these files.)
%
%\subsection{Layout}
%
%Print manuscripts two columns to a page, in the manner in which these
%instructions are printed. The exact dimensions for pages are:
%\begin{itemize}
%\item left and right margins: .75$''$
%\item column width: 3.375$''$
%\item gap between columns: .25$''$
%\item top margin---first page: 1.375$''$
%\item top margin---other pages: .75$''$
%\item bottom margin: 1.25$''$
%\item column height---first page: 6.625$''$
%\item column height---other pages: 9$''$
%\end{itemize}
%
%All measurements assume an 8-1/2$''$ $\times$ 11$''$ page size. For
%A4-size paper, use the given top and left margins, column width,
%height, and gap, and modify the bottom and right margins as necessary.
%
%\subsection{Format of Electronic Manuscript}
%
%For the production of the electronic manuscript, you must use Adobe's
%{\em Portable Document Format} (PDF). A PDF file can be generated, for
%instance, on Unix systems using {\tt ps2pdf} or on Windows systems
%using Adobe's Distiller. There is also a website with free software
%and conversion services: {\tt http://www.ps2pdf.com/}. For reasons of
%uniformity, use of Adobe's {\em Times Roman} font is strongly suggested. In
%\LaTeX2e{}, this is accomplished by putting
%\begin{quote} 
%\mbox{\tt $\backslash$usepackage\{times\}}
%\end{quote}
%in the preamble.\footnote{You may want also to use the package {\tt
%latexsym}, which defines all symbols known from the old \LaTeX{}
%version.}
%  
%Additionally, it is of utmost importance to specify the American {\bf
%letter} format (corresponding to 8-1/2$''$ $\times$ 11$''$) when
%formatting the paper. When working with {\tt dvips}, for instance, one
%should specify {\tt -t letter}.
%
%\subsection{Title and Author Information}
%
%Center the title on the entire width of the page in a 14-point bold
%font. Below it, center the author name(s) in a 12-point bold font, and
%then center the address(es) in a 12-point regular font. Credit to a
%sponsoring agency can appear on the first page as a footnote.
%
%\subsubsection{Blind Review}
%
%In order to make blind reviewing possible, authors must omit their
%names and affiliations when submitting the paper for review. In place
%of names and affiliations, provide a list of content areas. When
%referring to one's own work, use the third person rather than the
%first person. For example, say, ``Previously,
%Gottlob~\shortcite{gottlob:nonmon} has shown that\ldots'', rather
%than, ``In our previous work~\cite{gottlob:nonmon}, we have shown
%that\ldots'' Try to avoid including any information in the body of the
%paper or references that would identify the authors or their
%institutions. Such information can be added to the final camera-ready
%version for publication.
%
%\subsection{Abstract}
%
%Place the abstract at the beginning of the first column 3$''$ from the
%top of the page, unless that does not leave enough room for the title
%and author information. Use a slightly smaller width than in the body
%of the paper. Head the abstract with ``Abstract'' centered above the
%body of the abstract in a 12-point bold font. The body of the abstract
%should be in the same font as the body of the paper.
%
%The abstract should be a concise, one-paragraph summary describing the
%general thesis and conclusion of your paper. A reader should be able
%to learn the purpose of the paper and the reason for its importance
%from the abstract. The abstract should be no more than 200 words long.
%
%\subsection{Text}
%
%The main body of the text immediately follows the abstract. Use
%10-point type in a clear, readable font with 1-point leading (10 on
%11).
%
%Indent when starting a new paragraph, except after major headings.
%
%\subsection{Headings and Sections}
%
%When necessary, headings should be used to separate major sections of
%your paper. (These instructions use many headings to demonstrate their
%appearance; your paper should have fewer headings.)
%
%\subsubsection{Section Headings}
%
%Print section headings in 12-point bold type in the style shown in
%these instructions. Leave a blank space of approximately 10 points
%above and 4 points below section headings.  Number sections with
%arabic numerals.
%
%\subsubsection{Subsection Headings}
%
%Print subsection headings in 11-point bold type. Leave a blank space
%of approximately 8 points above and 3 points below subsection
%headings. Number subsections with the section number and the
%subsection number (in arabic numerals) separated by a
%period.
%
%\subsubsection{Subsubsection Headings}
%
%Print subsubsection headings in 10-point bold type. Leave a blank
%space of approximately 6 points above subsubsection headings. Do not
%number subsubsections.
%
%\subsubsection{Special Sections}
%
%You may include an unnumbered acknowledgments section, including
%acknowledgments of help from colleagues, financial support, and
%permission to publish.
%
%Any appendices directly follow the text and look like sections, except
%that they are numbered with capital letters instead of arabic
%numerals.
%
%The references section is headed ``References,'' printed in the same
%style as a section heading but without a number. A sample list of
%references is given at the end of these instructions. Use a consistent
%format for references, such as that provided by Bib\TeX{}. The reference
%list should not include unpublished work.
%
%\subsection{Citations}
%
%Citations within the text should include the author's last name and
%the year of publication, for example~\cite{gottlob:nonmon}.  Append
%lowercase letters to the year in cases of ambiguity.  Treat multiple
%authors as in the following examples:~\cite{abelson-et-al:scheme}
%or~\cite{bgf:Lixto} (for more than two authors) and
%\cite{brachman-schmolze:kl-one} (for two authors).  If the author
%portion of a citation is obvious, omit it, e.g.,
%Nebel~\shortcite{nebel:jair-2000}.  Collapse multiple citations as
%follows:~\cite{gls:hypertrees,levesque:functional-foundations}.
%\nocite{abelson-et-al:scheme}
%\nocite{bgf:Lixto}
%\nocite{brachman-schmolze:kl-one}
%\nocite{gottlob:nonmon}
%\nocite{gls:hypertrees}
%\nocite{levesque:functional-foundations}
%\nocite{levesque:belief}
%\nocite{nebel:jair-2000}
%
%\subsection{Footnotes}
%
%Place footnotes at the bottom of the page in a 9-point font.  Refer to
%them with superscript numbers.\footnote{This is how your footnotes
%should appear.} Separate them from the text by a short
%line.\footnote{Note the line separating these footnotes from the
%text.} Avoid footnotes as much as possible; they interrupt the flow of
%the text.
%
%\section{Illustrations}
%
%Place all illustrations (figures, drawings, tables, and photographs)
%throughout the paper at the places where they are first discussed,
%rather than at the end of the paper. If placed at the bottom or top of
%a page, illustrations may run across both columns.
%
%Illustrations must be rendered electronically or scanned and placed
%directly in your document. All illustrations should be in black and
%white, as color illustrations may cause problems. Line weights should
%be 1/2-point or thicker. Avoid screens and superimposing type on
%patterns as these effects may not reproduce well.
%
%Number illustrations sequentially. Use references of the following
%form: Figure 1, Table 2, etc. Place illustration numbers and captions
%under illustrations. Leave a margin of 1/4-inch around the area
%covered by the illustration and caption.  Use 9-point type for
%captions, labels, and other text in illustrations.
%
%\section*{Acknowledgments}
%
%The preparation of these instructions and the \LaTeX{} and Bib\TeX{}
%files that implement them was supported by Schlumberger Palo Alto
%Research, AT\&T Bell Laboratories, and Morgan Kaufmann Publishers.
%Preparation of the Microsoft Word file was supported by IJCAI.  An
%early version of this document was created by Shirley Jowell and Peter
%F. Patel-Schneider.  It was subsequently modified by Jennifer
%Ballentine and Thomas Dean, Bernhard Nebel, and Daniel Pagenstecher.
%These instructions are the same as the ones for IJCAI--05, prepared by
%Kurt Steinkraus, Massachusetts Institute of Technology, Computer
%Science and Artificial Intelligence Lab.
%
%\appendix
%
%\section{\LaTeX{} and Word Style Files}\label{stylefiles}
%
%The \LaTeX{} and Word style files are available on the IJCAI--11
%website, {\tt http://www.ijcai-11.org/}.
%These style files implement the formatting instructions in this
%document.
%
%The \LaTeX{} files are {\tt ijcai11.sty} and {\tt ijcai11.tex}, and
%the Bib\TeX{} files are {\tt named.bst} and {\tt ijcai11.bib}. The
%\LaTeX{} style file is for version 2e of \LaTeX{}, and the Bib\TeX{}
%style file is for version 0.99c of Bib\TeX{} ({\em not} version
%0.98i). The {\tt ijcai11.sty} file is the same as the {\tt
%ijcai07.sty} file used for IJCAI--07.
%
%The Microsoft Word style file consists of a single file, {\tt
%ijcai11.doc}. This template is the same as the one used for
%IJCAI--07.
%
%These Microsoft Word and \LaTeX{} files contain the source of the
%present document and may serve as a formatting sample.  
%
%Further information on using these styles for the preparation of
%papers for IJCAI--11 can be obtained by contacting {\tt
%pcchair11@ijcai.org}.

%% The file named.bst is a bibliography style file for BibTeX 0.99c
\bibliographystyle{named}
\bibliography{../bib}

\end{document}

